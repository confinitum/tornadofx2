<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AutoCompleteComboBoxSkin.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tornadofx2</a> &gt; <a href="index.source.html" class="el_package">tornadofx</a> &gt; <span class="el_source">AutoCompleteComboBoxSkin.kt</span></div><h1>AutoCompleteComboBoxSkin.kt</h1><pre class="source lang-java linenums">package tornadofx

import javafx.beans.property.SimpleStringProperty
import javafx.collections.FXCollections
import javafx.collections.ObservableList
import javafx.css.PseudoClass
import javafx.event.EventHandler
import javafx.scene.AccessibleRole
import javafx.scene.Node
import javafx.scene.control.*
import javafx.scene.control.skin.ComboBoxPopupControl
import javafx.scene.input.KeyCode
import javafx.scene.input.KeyEvent
import javafx.util.Callback


/**
 * Extension function to combobox to add autocomplete capabilities
 * Accept in parameter a callback to create the autocomplete list based on input text
 * Default filter use the string produced by the converter of combobox and search with contains ignore case the occurrence of typed text
 * @param automaticPopupWidth Use the width required to display all content. Default: true
 */
<span class="nc" id="L23">fun &lt;T&gt; ComboBox&lt;T&gt;.makeAutocompletable(automaticPopupWidth: Boolean = true, autoCompleteFilter: ((String) -&gt; List&lt;T&gt;)? = null) {</span>
<span class="nc" id="L24">    skin = AutoCompleteComboBoxSkin(this, autoCompleteFilter, automaticPopupWidth)</span>
<span class="nc" id="L25">}</span>

interface Resettable {
    fun reset()
}

interface FilterHandler {
    fun handleFilterChange(text : String)
    fun validateSelection()
    fun showSuggestion() : Boolean
    fun hideSuggestion() : Boolean

}

<span class="nc" id="L39">class FilterTooltipHandler(val control : Control, val filterHandler : FilterHandler) : EventHandler&lt;KeyEvent&gt; , Resettable {</span>

<span class="nc" id="L41">    private val filter = SimpleStringProperty(&quot;&quot;)</span>
<span class="nc" id="L42">    private val tooltip = Tooltip()</span>

<span class="nc" id="L44">    init {</span>
<span class="nc" id="L45">        tooltip.textProperty().bind(filter)</span>
<span class="nc" id="L46">        filter.addListener { _, _, newValue -&gt; handleFilterChanged_(newValue) }</span>
<span class="nc" id="L47">    }</span>

    override fun handle(event: KeyEvent) {
<span class="nc" id="L50">        val code = event.code</span>
<span class="nc" id="L51">        val isControlDown = event.isControlDown</span>
<span class="nc" id="L52">        val isShiftDown = event.isShiftDown</span>
<span class="nc" id="L53">        var filterValue: String = filter.get()</span>

<span class="nc bnc" id="L55" title="All 2 branches missed.">        if (isControlDown) {</span>
<span class="nc bnc" id="L56" title="All 4 branches missed.">            when (code) {</span>
<span class="nc" id="L57">                KeyCode.V -&gt; Unit</span>
<span class="nc" id="L58">                else -&gt; return</span>
            }
        }
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (isShiftDown) {</span>
<span class="nc bnc" id="L62" title="All 4 branches missed.">            when (code) {</span>
<span class="nc" id="L63">                KeyCode.LEFT, KeyCode.RIGHT, KeyCode.HOME, KeyCode.END -&gt; return</span>
<span class="nc" id="L64">                else -&gt; Unit</span>
            }
        }

<span class="nc bnc" id="L68" title="All 8 branches missed.">        when (code) {</span>
            KeyCode.DOWN, KeyCode.UP -&gt; {
<span class="nc" id="L70">                filterHandler.showSuggestion()</span>
            }
            KeyCode.BACK_SPACE -&gt; {
<span class="nc bnc" id="L73" title="All 4 branches missed.">                if(filterValue.isNotBlank()) {</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">                    filterValue = filterValue.substring(0, filterValue.length - 1)</span>
                }
            }
            KeyCode.ESCAPE -&gt; {
<span class="nc" id="L78">                reset()</span>
<span class="nc" id="L79">                filterHandler.hideSuggestion()</span>
<span class="nc" id="L80">                return</span>
            }
            KeyCode.ENTER -&gt; {
<span class="nc" id="L83">                filterHandler.validateSelection()</span>
<span class="nc" id="L84">                return</span>
            }
<span class="nc" id="L86">            KeyCode.RIGHT, KeyCode.LEFT, KeyCode.HOME, KeyCode.END, KeyCode.TAB, KeyCode.SHIFT, KeyCode.CONTROL -&gt; return</span>
<span class="nc" id="L87">            else -&gt; filterValue += event.text</span>
        }

<span class="nc" id="L90">        filter.value = filterValue</span>
<span class="nc" id="L91">    }</span>

    private fun handleFilterChanged_(newValue: String) {
<span class="nc" id="L94">        filterHandler.handleFilterChange(newValue)</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">        if(newValue.isNotBlank()) {</span>
<span class="nc" id="L96">            showTooltip()</span>
        } else {
<span class="nc" id="L98">            tooltip.hide()</span>
        }
<span class="nc" id="L100">    }</span>

    private fun showTooltip() {
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (!tooltip.isShowing) {</span>
<span class="nc" id="L104">            val stage = control.scene.window</span>
<span class="nc" id="L105">            val posX = stage.x + control.localToScene(control.boundsInLocal).minX</span>
<span class="nc" id="L106">            val posY = stage.y + control.localToScene(control.boundsInLocal).minY</span>
<span class="nc" id="L107">            tooltip.show(stage, posX, posY)</span>
        }
<span class="nc" id="L109">    }</span>

    override fun reset() {
<span class="nc" id="L112">        filter.value = &quot;&quot;</span>
<span class="nc" id="L113">        tooltip.hide()</span>
<span class="nc" id="L114">    }</span>

}


<span class="nc" id="L119">class FilterInputTextHandler(val editor : TextField, val filterHandler : FilterHandler) : EventHandler&lt;KeyEvent&gt;, Resettable {</span>
<span class="nc" id="L120">    private var lastText: String = &quot;&quot;</span>

    override fun handle(event: KeyEvent) {
<span class="nc" id="L123">        val text = editor.text</span>
<span class="nc" id="L124">        val inputChanged = lastText != text</span>
<span class="nc" id="L125">        lastText = text</span>
<span class="nc" id="L126">        val code = event.code</span>
<span class="nc" id="L127">        val isControlDown = event.isControlDown</span>
<span class="nc" id="L128">        val isShiftDown = event.isShiftDown</span>
<span class="nc" id="L129">        val caretPosition = editor.caretPosition</span>

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (isControlDown) {</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">            when (code) {</span>
<span class="nc" id="L133">                KeyCode.V -&gt; Unit</span>
<span class="nc" id="L134">                else -&gt; return</span>
            }
        }
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (isShiftDown) {</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">            when (code) {</span>
<span class="nc" id="L139">                KeyCode.LEFT, KeyCode.RIGHT, KeyCode.HOME, KeyCode.END -&gt; return</span>
<span class="nc" id="L140">                else -&gt; Unit</span>
            }
        }

<span class="nc bnc" id="L144" title="All 7 branches missed.">        when (code) {</span>
            KeyCode.DOWN, KeyCode.UP -&gt; {
<span class="nc bnc" id="L146" title="All 2 branches missed.">                if(!filterHandler.showSuggestion()) {</span>
<span class="nc" id="L147">                    editor.positionCaret(text.length)</span>
                }
<span class="nc" id="L149">                return</span>
            }
            KeyCode.ESCAPE -&gt; {
<span class="nc" id="L152">                filterHandler.hideSuggestion()</span>
<span class="nc" id="L153">                return</span>
            }
            KeyCode.ENTER -&gt; {
<span class="nc" id="L156">                filterHandler.validateSelection()</span>
<span class="nc" id="L157">                return</span>
            }
<span class="nc" id="L159">            KeyCode.RIGHT, KeyCode.LEFT, KeyCode.HOME, KeyCode.END, KeyCode.TAB, KeyCode.SHIFT, KeyCode.CONTROL -&gt; return</span>
<span class="nc" id="L160">            else -&gt; Unit</span>
        }

<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (inputChanged) {</span>
<span class="nc" id="L164">            filterHandler.handleFilterChange(text)</span>
<span class="nc" id="L165">            editor.text = text</span>
<span class="nc" id="L166">            editor.positionCaret(caretPosition)</span>
        }
<span class="nc" id="L168">    }</span>

    override fun reset() {
<span class="nc" id="L171">        lastText = &quot;&quot;</span>
<span class="nc" id="L172">    }</span>
}

/**
 * Auto Complete support for combobox
 * Accept a call back to make custom filter
 * Default filter use the string produced by the converter of combobox and search with contains ignore case the occurrence of typed text
 * Created by anouira on 15/02/2017.
 */
<span class="nc" id="L181">open class AutoCompleteComboBoxSkin&lt;T&gt;(val comboBox: ComboBox&lt;T&gt;, autoCompleteFilter: ((String) -&gt; List&lt;T&gt;)?, automaticPopupWidth: Boolean) : ComboBoxPopupControl&lt;T&gt;(comboBox), FilterHandler {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">    var autoCompleteFilter_: (String) -&gt; List&lt;T&gt; = autoCompleteFilter ?: {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        comboBox.items.filter { current -&gt; comboBox.converter.toString(current).contains(it, true) }</span>
    }

<span class="nc" id="L186">    protected val listView = ListView&lt;T&gt;(comboBox.items)</span>
    private var skipValueUpdate = false
<span class="nc bnc" id="L188" title="All 2 branches missed.">    private var comboBoxItems: ObservableList&lt;T&gt; = if (comboBox.items == null) FXCollections.emptyObservableList&lt;T&gt;() else comboBox.items</span>

<span class="nc" id="L190">    private val filterHandler by lazy&lt;EventHandler&lt;KeyEvent&gt;&gt; {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if(comboBox.isEditable) {</span>
<span class="nc" id="L192">            FilterInputTextHandler(comboBox.editor, this)</span>

        } else {
<span class="nc" id="L195">            FilterTooltipHandler(comboBox, this)</span>
        }

    }

<span class="nc" id="L200">    init {</span>
<span class="nc" id="L201">        with(comboBox) {</span>
<span class="nc" id="L202">            onKeyReleased = filterHandler</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            focusedProperty().onChange { focus -&gt; if(!focus) {</span>
<span class="nc" id="L204">                resetFilter()</span>
<span class="nc" id="L205">                comboBox.hide()</span>
<span class="nc" id="L206">            }}</span>
<span class="nc bnc" id="L207" title="All 6 branches missed.">            childrenUnmodifiable.find { it.id == &quot;arrow-button&quot; }?.setOnMouseClicked {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                if (isShowing) {</span>
<span class="nc" id="L209">                    resetFilter()</span>
                }
<span class="nc" id="L211">            }</span>
        }
<span class="nc" id="L213">        listView.selectionModel.selectedItemProperty().onChange {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (!skipValueUpdate) comboBox.value = it</span>
<span class="nc" id="L215">        }</span>
<span class="nc" id="L216">        listView.onUserSelect(clickCount = 1) {</span>
<span class="nc" id="L217">            comboBox.value = it</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            if(filterHandler is FilterTooltipHandler) {</span>
<span class="nc" id="L219">                resetFilter()</span>
            }
<span class="nc" id="L221">            comboBox.hide()</span>
<span class="nc" id="L222">            updateDisplayArea()</span>
<span class="nc" id="L223">        }</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (!automaticPopupWidth) {</span>
            // Note that we cannot bind prefWidthProperty because JavaFX sets
            // the preferred width upon reconfiguration. (ComboBoxPopupControl.java:322)
<span class="nc" id="L227">            comboBox.widthProperty().onChange {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (!listView.prefWidthProperty().isBound) listView.prefWidth = it</span>
<span class="nc" id="L229">            }</span>
        }
<span class="nc" id="L231">        updateCellFactory()</span>
<span class="nc" id="L232">        updateButtonCell()</span>
<span class="nc" id="L233">        updateValue()</span>
<span class="nc" id="L234">        comboBox.cellFactoryProperty().onChange { updateCellFactory() }</span>
<span class="nc" id="L235">    }</span>

    override fun handleFilterChange(text : String) {
<span class="nc" id="L238">        val list = autoCompleteFilter_.invoke(text)</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">        listView.items = (list as? ObservableList&lt;T&gt;) ?: list.asObservable()</span>
<span class="nc" id="L240">        listView.requestLayout()</span>

<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (list.isEmpty()) {</span>
<span class="nc" id="L243">            comboBox.hide()</span>
        } else {
<span class="nc" id="L245">            comboBox.show()</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (listView.selectedItem == null) {</span>
<span class="nc" id="L247">                skipValueUpdate = true</span>
<span class="nc" id="L248">                listView.selectionModel.selectFirst()</span>
<span class="nc" id="L249">                skipValueUpdate = false</span>
            }
<span class="nc" id="L251">            listView.requestFocus()</span>
        }
<span class="nc" id="L253">    }</span>

    /** Specific auto complete implementation */
    override fun validateSelection() {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (!listView.selectionModel.isEmpty) {</span>
<span class="nc" id="L258">            comboBox.value = listView.selectedItem</span>
        }
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (comboBox.isShowing) {</span>
<span class="nc" id="L261">            comboBox.hide()</span>
        }
<span class="nc" id="L263">    }</span>

    override fun showSuggestion() : Boolean {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if(!comboBox.isShowing) {</span>
<span class="nc" id="L267">            comboBox.show()</span>
<span class="nc" id="L268">            return true</span>
        }
<span class="nc" id="L270">        return false</span>
    }

    override fun hideSuggestion() : Boolean {
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if(comboBox.isShowing) {</span>
<span class="nc" id="L275">            comboBox.hide()</span>
<span class="nc" id="L276">            return true</span>
        }
<span class="nc" id="L278">        return false</span>
    }

    private fun updateCellFactory() {
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (comboBox.cellFactory != null) {</span>
<span class="nc" id="L283">            listView.cellFactory = comboBox.cellFactory</span>
        } else {
<span class="nc" id="L285">            createDefaultCellFactory()</span>
        }
<span class="nc" id="L287">    }</span>

    private fun createDefaultCellFactory() {
<span class="nc" id="L290">        val cellFormat: (ListCell&lt;T&gt;.(T) -&gt; Unit) = {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (it is Node) {</span>
<span class="nc" id="L292">                graphic = it</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            } else if (it != null) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                if (converter != null)</span>
<span class="nc" id="L295">                    text = converter.toString(it)</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                else if (it is String)</span>
<span class="nc" id="L297">                    text = it</span>
                else
<span class="nc" id="L299">                    text = it.toString()</span>
            }
<span class="nc" id="L301">        }</span>
<span class="nc" id="L302">        listView.properties[&quot;tornadofx.cellFormat&quot;] = cellFormat</span>
<span class="nc" id="L303">        listView.cellFactory = Callback { SmartListCell(FX.defaultScope, listView) }</span>
<span class="nc" id="L304">    }</span>

    private fun resetFilter() {
<span class="nc" id="L307">        listView.items = comboBox.items</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">        (filterHandler as? Resettable)?.reset()</span>
<span class="nc" id="L309">    }</span>

    /** End of Specific auto complete implementation */

    /** Implementation copied from ComboBoxListViewSkin */
    private var buttonCell: ListCell&lt;T&gt;? = null

    // These three pseudo class states are duplicated from Cell
<span class="nc" id="L317">    private val PSEUDO_CLASS_SELECTED = PseudoClass.getPseudoClass(&quot;selected&quot;)</span>
<span class="nc" id="L318">    private val PSEUDO_CLASS_EMPTY = PseudoClass.getPseudoClass(&quot;empty&quot;)</span>
<span class="nc" id="L319">    private val PSEUDO_CLASS_FILLED = PseudoClass.getPseudoClass(&quot;filled&quot;)</span>

    override fun getDisplayNode(): Node? {
<span class="nc" id="L322">        val displayNode: Node?</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (comboBox.isEditable) {</span>
<span class="nc" id="L324">            displayNode = editor</span>
        } else {
<span class="nc bnc" id="L326" title="All 2 branches missed.">            displayNode = buttonCell as Node</span>
        }

<span class="nc" id="L329">        updateDisplayNode()</span>

<span class="nc" id="L331">        return displayNode</span>
    }

    private fun updateButtonCell() {
<span class="nc bnc" id="L335" title="All 2 branches missed.">        buttonCell = if (comboBox.buttonCell != null)</span>
<span class="nc" id="L336">            comboBox.buttonCell</span>
        else
<span class="nc" id="L338">            getDefaultCellFactory().call(listView)</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        buttonCell?.setMouseTransparent(true)</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        buttonCell?.updateListView(listView)</span>
<span class="nc" id="L341">        updateDisplayArea()</span>
        // As long as the screen-reader is concerned this node is not a list item.
        // This matters because the screen-reader counts the number of list item
        // within combo and speaks it to the user.
<span class="nc bnc" id="L345" title="All 2 branches missed.">        buttonCell?.setAccessibleRole(AccessibleRole.NODE)</span>
<span class="nc" id="L346">    }</span>

    private fun getDefaultCellFactory(): Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; {
<span class="nc" id="L349">        return Callback {</span>
<span class="nc" id="L350">            object : ListCell&lt;T&gt;() {</span>
                public override fun updateItem(item: T, empty: Boolean) {
<span class="nc" id="L352">                    super.updateItem(item, empty)</span>
<span class="nc" id="L353">                    updateDisplayText(this, item, empty)</span>
<span class="nc" id="L354">                }</span>
            }
        }
    }

    private fun updateDisplayText(cell: ListCell&lt;T&gt;?, item: T?, empty: Boolean): Boolean {
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (empty) {</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (cell == null) return true</span>
<span class="nc" id="L362">            cell.graphic = null</span>
<span class="nc" id="L363">            cell.text = null</span>
<span class="nc" id="L364">            return true</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        } else if (item is Node) {</span>
<span class="nc" id="L366">            val currentNode = cell!!.graphic</span>
<span class="nc" id="L367">            val newNode = item</span>
<span class="nc bnc" id="L368" title="All 4 branches missed.">            if (currentNode == null || currentNode != newNode) {</span>
<span class="nc" id="L369">                cell.text = null</span>
<span class="nc" id="L370">                cell.graphic = newNode</span>
            }
<span class="nc" id="L372">            return false</span>
        } else {
            // run item through StringConverter if it isn't null
<span class="nc" id="L375">            val c = comboBox.converter</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">            val s = if (item == null) comboBox.promptText else if (c == null) item.toString() else c.toString(item)</span>
<span class="nc" id="L377">            cell!!.text = s</span>
<span class="nc" id="L378">            cell.graphic = null</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">            return s.isNullOrEmpty()</span>
        }
    }

    private fun updateValue() {
<span class="nc" id="L384">        val newValue = comboBox.value</span>

<span class="nc" id="L386">        val listViewSM = listView.selectionModel</span>

<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (newValue == null) {</span>
<span class="nc" id="L389">            listViewSM.clearSelection()</span>
        } else {
            // RT-22386: We need to test to see if the value is in the comboBox
            // items list. If it isn't, then we should clear the listview
            // selection
<span class="nc" id="L394">            val indexOfNewValue = getIndexOfComboBoxValueInItemsList()</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (indexOfNewValue == -1) {</span>
                //listSelectionLock = true
<span class="nc" id="L397">                listViewSM.clearSelection()</span>
                //listSelectionLock = false
            } else {
<span class="nc" id="L400">                val index = comboBox.selectionModel.selectedIndex</span>
<span class="nc bnc" id="L401" title="All 4 branches missed.">                if (index in comboBoxItems.indices) {</span>
<span class="nc" id="L402">                    val itemsObj = comboBoxItems.get(index)</span>
<span class="nc bnc" id="L403" title="All 4 branches missed.">                    if (itemsObj != null &amp;&amp; itemsObj == newValue) {</span>
<span class="nc" id="L404">                        listViewSM.select(index)</span>
                    } else {
<span class="nc" id="L406">                        listViewSM.select(newValue)</span>
<span class="nc" id="L407">                    }</span>
                } else {
                    // just select the first instance of newValue in the list
<span class="nc" id="L410">                    val listViewIndex = comboBoxItems.indexOf(newValue)</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    if (listViewIndex == -1) {</span>
                        // RT-21336 Show the ComboBox value even though it doesn't
                        // exist in the ComboBox items list (part one of fix)
<span class="nc" id="L414">                        updateDisplayNode()</span>
                    } else {
<span class="nc" id="L416">                        listViewSM.select(listViewIndex)</span>
                    }
                }
            }
        }
<span class="nc" id="L421">    }</span>

    private fun getIndexOfComboBoxValueInItemsList(): Int {
<span class="nc" id="L424">        val value = comboBox.value</span>
<span class="nc" id="L425">        val index = comboBoxItems.indexOf(value)</span>
<span class="nc" id="L426">        return index</span>
    }

    fun updateDisplayNode() {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (editor != null) {</span>
<span class="nc" id="L431">            ReflectionUtils.callMethod(this, this.javaClass.superclass, &quot;updateDisplayNode&quot;)</span>
        } else {
<span class="nc" id="L433">            val value = comboBox.value</span>
<span class="nc" id="L434">            val index = getIndexOfComboBoxValueInItemsList()</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (index &gt; -1) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                buttonCell?.setItem(null)</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                buttonCell?.updateIndex(index)</span>
            } else {
                // RT-21336 Show the ComboBox value even though it doesn't
                // exist in the ComboBox items list (part two of fix)
<span class="nc bnc" id="L441" title="All 2 branches missed.">                buttonCell?.updateIndex(-1)</span>
<span class="nc" id="L442">                val empty = updateDisplayText(buttonCell, value, false)</span>

                // Note that empty boolean collected above. This is used to resolve
                // RT-27834, where we were getting different styling based on whether
                // the cell was updated via the updateIndex method above, or just
                // by directly updating the text. We fake the pseudoclass state
                // for empty, filled, and selected here.
<span class="nc bnc" id="L449" title="All 2 branches missed.">                buttonCell?.pseudoClassStateChanged(PSEUDO_CLASS_EMPTY, empty)</span>
<span class="nc bnc" id="L450" title="All 4 branches missed.">                buttonCell?.pseudoClassStateChanged(PSEUDO_CLASS_FILLED, !empty)</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                buttonCell?.pseudoClassStateChanged(PSEUDO_CLASS_SELECTED, true)</span>
            }
        }
<span class="nc" id="L454">    }</span>

<span class="nc" id="L456">    override fun getPopupContent() = listView</span>

<span class="nc bnc" id="L458" title="All 4 branches missed.">    override fun getEditor() = if (skinnable.isEditable) (skinnable as ComboBox&lt;T&gt;).editor else null</span>

<span class="nc bnc" id="L460" title="All 2 branches missed.">    override fun getConverter() = (skinnable as ComboBox&lt;T&gt;).converter</span>

    /* End of Implementation copied from ComboBoxListViewSkin */

    fun updateDisplayArea() {
<span class="nc" id="L465">        ReflectionUtils.callMethod(this, this.javaClass.superclass.superclass, &quot;updateDisplayArea&quot;)</span>
<span class="nc" id="L466">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>